import apiService from './apiService';

class PaymentService {
  constructor() {
    // Use API service directly, no need for separate base URL
    this.apiService = apiService;
  }

  /**
   * Generate voucher code
   */
  generateVoucherCode() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);
    return `VCH${timestamp}${random}`;
  }

  /**
   * Validate payment data
   */
  validatePaymentData(paymentData) {
    const errors = [];

    if (!paymentData.customerName || paymentData.customerName.trim() === '') {
      errors.push('Customer name is required');
    }

    if (!paymentData.phoneNumber || paymentData.phoneNumber.trim() === '') {
      errors.push('Phone number is required');
    }

    // Location is optional - removed requirement
    // if (!paymentData.location || paymentData.location.trim() === '') {
    //   errors.push('Location is required');
    // }

    if (!paymentData.packageId) {
      errors.push('Package selection is required');
    }

    if (!paymentData.amount || paymentData.amount <= 0) {
      errors.push('Valid amount is required');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Initiate ZenoPay payment
   */
  async initiateZenoPayPayment(paymentData) {
    try {
      const validation = this.validatePaymentData(paymentData);
      if (!validation.isValid) {
        throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
      }

      const formattedPaymentData = {
        customerName: paymentData.customerName.trim(),
        phoneNumber: paymentData.phoneNumber.trim(),
        // Location is optional - removed from required fields
        // location: paymentData.location ? paymentData.location.trim() : undefined,
        packageId: paymentData.packageId,
        packageName: paymentData.packageName,
        amount: paymentData.amount,
        currency: paymentData.currency || 'TZS',
        paymentMethod: 'ZENOPAY'
        // Voucher code is generated by backend, not frontend
        // voucherCode: this.generateVoucherCode()
      };

      console.log('üöÄ Initiating ZenoPay Payment:', formattedPaymentData);

      const response = await apiService.initiatePayment(formattedPaymentData);
      
      console.log('üîç Payment API Response:', response);
      console.log('üîç Response Status:', response.status);
      console.log('üîç Response Type:', typeof response.status);
      
      if (response.status === 'success') {
        return {
          status: 'success',
          order_id: response.order_id,
          voucher_code: response.voucher_code,
          message: response.message,
          zenopay_response: response.zenopay_response
        };
      } else {
        throw new Error(response.message || 'Payment initiation failed');
      }
    } catch (error) {
      console.error('‚ùå ZenoPay Payment Error:', error);
      throw error;
    }
  }

  /**
   * Check payment status
   */
  async checkPaymentStatus(orderId) {
    try {
      console.log(`üîç Checking payment status for order: ${orderId}`);
      const response = await apiService.checkPaymentStatus(orderId);
      console.log(`üîç Payment status response:`, response);
      return response;
    } catch (error) {
      console.error(`‚ùå Error checking payment status: ${error.message}`);
      throw error;
    }
  }

  /**
   * Get user-friendly message for payment status
   */
  getStatusMessage(status) {
    const statusMessages = {
      // Backend enum statuses
      'PENDING': 'Payment is still being processed. Please complete the payment on your phone.',
      'PROCESSING': 'Payment is being processed. Please wait...',
      'COMPLETED': 'Payment completed successfully! Your voucher code has been generated.',
      'SUCCESSFUL': 'Payment completed successfully! Your voucher code has been generated.',
      'SUCCESS': 'Payment completed successfully! Your voucher code has been generated.',
      'FAILED': 'Payment failed. Please check your mobile money balance and try again.',
      'CANCELLED': 'Payment was cancelled. Please try again.',
      'REFUNDED': 'Payment has been refunded.',
      'EXPIRED': 'Payment has expired. Please initiate a new payment.',
      
      // Webhook-specific statuses
      'INSUFFICIENT_BALANCE': 'Insufficient balance in your mobile money account. Please top up and try again.',
      'INVALID_PIN': 'Invalid PIN entered. Please try again with the correct PIN.',
      'USER_CANCELLED': 'Payment was cancelled by user. Please try again.',
      'TIMEOUT': 'Payment timed out. Please try again.',
      'NETWORK_ERROR': 'Network error occurred. Please try again.',
      'ERROR': 'An error occurred during payment. Please try again.'
    };
    return statusMessages[status] || `Payment status: ${status}`;
  }

  /**
   * Poll payment status with enhanced tracking
   */
  // USSD timeout is 60 seconds, so we poll for 60 seconds (30 attempts √ó 2s interval)
  async pollPaymentStatus(orderId, onStatusUpdate, maxAttempts = 30, interval = 2000) {
    console.log(`üîÑ Starting payment status polling for order: ${orderId}`);
    console.log(`   Max attempts: ${maxAttempts}, Interval: ${interval}ms`);
    
    // Prevent multiple polling instances for the same order
    if (this.activePolling && this.activePolling.has(orderId)) {
      console.log(`‚ö†Ô∏è Polling already active for order: ${orderId}`);
      return () => {
        console.log(`üõë Ignoring duplicate polling stop for order: ${orderId}`);
      };
    }
    
    // Track active polling
    if (!this.activePolling) {
      this.activePolling = new Set();
    }
    this.activePolling.add(orderId);
    
    const startTime = Date.now();
    const maxElapsedSeconds = 60; // Maximum 60 seconds
    let attempts = 0;
    let pollInterval = null;
    
    // Immediate first poll (don't wait for interval)
    const performPoll = async () => {
      const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
      
      // Force timeout if 60 seconds elapsed, regardless of attempts
      if (elapsedSeconds >= maxElapsedSeconds) {
        console.log(`‚è∞ Payment polling timeout after ${elapsedSeconds}s (60s limit reached)`);
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
        this.activePolling.delete(orderId);
        if (onStatusUpdate) {
          onStatusUpdate({
            status: 'TIMEOUT',
            message: 'Payment timed out after 60 seconds. The USSD prompt has expired. Please initiate a new payment.',
            orderId: orderId,
            elapsedSeconds: elapsedSeconds,
            attempt: attempts
          });
        }
        return;
      }
      
      attempts++;
      console.log(`üîÑ Polling attempt ${attempts}/${maxAttempts} (${elapsedSeconds}s elapsed) for order: ${orderId}`);
      
      try {
        const result = await this.checkPaymentStatus(orderId);
        
        // Handle response - check both result.data and result directly
        const responseData = result.data || result;
        
        // Check if response has status field
        const responseStatus = responseData.status || 'success';
        const paymentStatus = (responseData.payment_status || responseData.paymentStatus || 'PENDING').toUpperCase();
        
        console.log(`üìä Payment status update: ${paymentStatus} (attempt ${attempts}, ${elapsedSeconds}s elapsed)`);
        console.log(`üìä Full response data:`, responseData);
        
        // Call the status update callback with elapsed time
        if (onStatusUpdate) {
          onStatusUpdate({
            status: paymentStatus,
            message: responseData.message || this.getStatusMessage(paymentStatus),
            orderId: responseData.order_id || responseData.orderId || orderId,
            voucherCode: responseData.voucher_code || responseData.voucherCode,
            voucherGenerated: responseData.voucher_generated || responseData.voucherGenerated || false,
            timestamp: responseData.timestamp || new Date().toISOString(),
            zenopayResponse: responseData.zenopay_response || responseData.zenopayResponse,
            failureReason: responseData.failure_reason || responseData.failureReason,
            elapsedSeconds: elapsedSeconds,
            attempt: attempts
          });
        }
        
        // Stop polling if payment is in final state
        const finalStatuses = ['COMPLETED', 'SUCCESS', 'SUCCESSFUL', 'FAILED', 'CANCELLED', 'EXPIRED', 
                               'TIMEOUT', 'INSUFFICIENT_BALANCE', 'INVALID_PIN', 
                               'USER_CANCELLED', 'NETWORK_ERROR', 'ERROR'];
        if (finalStatuses.includes(paymentStatus)) {
          console.log(`‚úÖ Payment polling completed with status: ${paymentStatus} after ${elapsedSeconds}s`);
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
          this.activePolling.delete(orderId);
          return;
        }
        
        // Also handle case where response status is error but payment_status might be in response
        if (responseStatus === 'error' && !paymentStatus) {
          console.log(`‚ö†Ô∏è Response indicates error but no payment_status found`);
          // Continue polling - might be temporary error
        }
        
        // Stop polling if max attempts reached (backup check)
        if (attempts >= maxAttempts) {
          console.log(`‚è∞ Payment polling timeout after ${maxAttempts} attempts (${elapsedSeconds}s)`);
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
          this.activePolling.delete(orderId);
          if (onStatusUpdate) {
            onStatusUpdate({
              status: 'TIMEOUT',
              message: 'Payment status check timed out after 60 seconds. Please initiate a new payment.',
              orderId: orderId,
              elapsedSeconds: elapsedSeconds,
              attempt: attempts
            });
          }
          return;
        }
        
      } catch (error) {
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        console.error(`‚ùå Error polling payment status (attempt ${attempts}/${maxAttempts}):`, {
          error: error.message,
          orderId,
          elapsedSeconds,
          errorType: error.name,
          errorStack: error.stack
        });
        
        // Provide user-friendly error messages based on error type
        let errorMessage = 'Failed to check payment status. Please try again.';
        if (error.message.includes('CORS') || error.message.includes('blocked')) {
          errorMessage = 'Connection blocked. Please check your network or contact support.';
        } else if (error.message.includes('Network') || error.message.includes('fetch')) {
          errorMessage = 'Network error. Please check your internet connection.';
        } else if (error.message.includes('timeout')) {
          errorMessage = 'Request timed out. Please try again.';
        }
        
        // Force timeout if 60 seconds elapsed even on error
        if (elapsedSeconds >= maxElapsedSeconds) {
          console.log(`‚è∞ Payment polling timeout after ${elapsedSeconds}s (error occurred but time limit reached)`);
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
          this.activePolling.delete(orderId);
          if (onStatusUpdate) {
            onStatusUpdate({
              status: 'TIMEOUT',
              message: 'Payment timed out after 60 seconds. Please initiate a new payment.',
              orderId: orderId,
              elapsedSeconds: elapsedSeconds,
              attempt: attempts,
              error: error.message
            });
          }
          return;
        }
        
        if (attempts >= maxAttempts) {
          console.log(`‚è∞ Payment polling failed after ${maxAttempts} attempts (${elapsedSeconds}s)`);
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
          this.activePolling.delete(orderId);
          if (onStatusUpdate) {
            onStatusUpdate({
              status: 'TIMEOUT',
              message: 'Payment status check timed out. Please initiate a new payment.',
              orderId: orderId,
              elapsedSeconds: elapsedSeconds,
              attempt: attempts,
              error: error.message
            });
          }
          return;
        }
        
        // Continue polling on error (will retry)
        console.log(`üîÑ Retrying payment status check (attempt ${attempts + 1}/${maxAttempts})...`);
      }
    };
    
    // Perform immediate first poll
    performPoll();
    
    // Then poll at regular intervals
    pollInterval = setInterval(performPoll, interval);
    
    // Safety timeout: Force stop after 65 seconds (5 seconds buffer)
    setTimeout(() => {
      if (pollInterval) {
        console.log(`‚è∞ Safety timeout: Forcing stop after 65 seconds`);
        clearInterval(pollInterval);
        pollInterval = null;
        this.activePolling.delete(orderId);
        if (onStatusUpdate) {
          onStatusUpdate({
            status: 'TIMEOUT',
            message: 'Payment timed out. Please initiate a new payment.',
            orderId: orderId,
            elapsedSeconds: 65,
            attempt: attempts
          });
        }
      }
    }, 65000); // 65 seconds safety timeout
    
    // Return a function to stop polling
    return () => {
      console.log(`üõë Stopping payment polling for order: ${orderId}`);
      console.log(`üõë Active polling before stop:`, this.activePolling);
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
      this.activePolling.delete(orderId);
      console.log(`üõë Active polling after stop:`, this.activePolling);
    };
  }

  /**
   * Process complete payment flow
   */
  async processPayment(paymentData) {
    try {
      // Step 1: Initiate payment
      const paymentResult = await this.initiateZenoPayPayment(paymentData);
      
      if (paymentResult.status === 'success') {
        // Step 2: Poll for payment completion
        const statusResult = await this.pollPaymentStatus(paymentResult.order_id);
        
        return {
          ...paymentResult,
          final_status: statusResult.status,
          payment_status: statusResult.payment_status,
          final_message: statusResult.message
        };
      } else {
        throw new Error(paymentResult.message);
      }
    } catch (error) {
      console.error('‚ùå Payment Process Error:', error);
      throw error;
    }
  }
}

const paymentService = new PaymentService();

export default paymentService;